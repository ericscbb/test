/**
  ******************************************************************************
  * @文件    stm32f10x_dac.c
  * @作者    MCD 應用程序組
  * @版本    V3.1.0
  * @日期    06/19/2009
  * @簡述    這個文件 提供所有 DAC 固件函數.
  * @翻譯    ANSON/sweet1985 Email:airanson110@126.com
  * @日期    18/07/2009
  ******************************************************************************
  * @復件
  *
  * 這個固件僅僅是提供給客戶作為設計產品而編寫程序的參考目的使客戶節約時間。由於
  * 客戶使用本固件在開發產品編程上產生的結果意法半導體公司不承擔任何直接的和間接
  * 的責任，也不承擔任何損害而引起的賠償。
  *
  * <h2><center>&複製; 版權所有 2009 意法半導體公司</center></h2>
  * 翻譯版本僅供學習，如與英文原版有出入應以英文原版為準。
  */ 

/* 包含 ------------------------------------------------------------------*/
#include "stm32f10x_dac.h"
#include "stm32f10x_rcc.h"

/* 自用類型 --------------------------------------------------------------*/
/* 自用定義 --------------------------------------------------------------*/

/* DAC EN mask */
#define CR_EN_Set                  ((uint32_t)0x00000001)

/* DAC DMAEN mask */
#define CR_DMAEN_Set               ((uint32_t)0x00001000)

/* CR register Mask */
#define CR_CLEAR_Mask              ((uint32_t)0x00000FFE)

/* DAC SWTRIG mask */
#define SWTRIGR_SWTRIG_Set         ((uint32_t)0x00000001)

/* DAC Dual Channels SWTRIG masks */
#define DUAL_SWTRIG_Set            ((uint32_t)0x00000003)
#define DUAL_SWTRIG_Reset          ((uint32_t)0xFFFFFFFC)

/* DHR registers offsets */
#define DHR12R1_Offset             ((uint32_t)0x00000008)
#define DHR12R2_Offset             ((uint32_t)0x00000014)
#define DHR12RD_Offset             ((uint32_t)0x00000020)

/* DOR register offset */
#define DOR_Offset                 ((uint32_t)0x0000002C)

/* 自用宏 -------------------------------------------------------------*/
/* 自用變量 -----------------------------------------------------------*/
/* 自用函數原型 -------------------------------------------------------*/
/* 自用函數 -----------------------------------------------------------*/

/**
  * @簡述  將 DAC 部件的寄存器復位為默認值
  * @參數  沒有
  * @返回  沒有
  */
void DAC_DeInit(void)
{
  /* 使能 DAC 復位狀態 */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
  /* 釋放 DAC 復位狀態 */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
}

/**
  * @簡述  依照 DAC_InitStruct 指定的參數初始化 DAC 外部設備.
  * @參數  DAC_Channel: 選定的 DAC 通道. 
  *          這個參數可以是下列值之一:
  *          DAC_Channel_1: 選定 DAC 通道1
  *          DAC_Channel_2: 選定 DAC 通道2
  * @參數  DAC_InitStruct: 指向包含了指定 DAC 通道配置信息的 DAC_InitTypeDef 結構指針.
  * @返回  沒有
  */
void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
{
  uint32_t tmpreg1 = 0, tmpreg2 = 0;
  /* 檢查參數 */
  assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
  assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
  assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
  assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
/*---------------------------- DAC CR Configuration --------------------------*/
  /* 得到 DAC CR 的值 */
  tmpreg1 = DAC->CR;
  /* 清除 BOFFx, TENx, TSELx, WAVEx 和 MAMPx 位 */
  tmpreg1 &= ~(CR_CLEAR_Mask << DAC_Channel);
  /* 配置選定的 DAC 通道: 緩衝輸出, 觸發器, 波形信號發生器,波形信號發生器的時標/振幅 */
  /* 設置 TSELx 和 TENx 位，按照 DAC_Trigger 的值 */
  /* 設置 WAVEx 位，按照 DAC_WaveGeneration 的值 */
  /* 設置 MAMPx 位，按照 DAC_LFSRUnmask_TriangleAmplitude 的值 */ 
  /* 設置 BOFFx 位，按照 DAC_OutputBuffer 的值 */   
  tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
             DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | DAC_InitStruct->DAC_OutputBuffer);
  /* 根據DAC_Channel計算CR寄存器值 */
  tmpreg1 |= tmpreg2 << DAC_Channel;
  /* 寫 DAC CR */
  DAC->CR = tmpreg1;
}

/**
  * @簡述  用默認值填充 DAC_InitStruct 結構的每一個成員.
  * @參數  DAC_InitStruct : 指向將要被初始化的 DAC_InitTypeDef 結構指針.
  * @返回  沒有
  */
void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
{
/*--------------- Reset DAC init structure parameters values -----------------*/
  /* 初始化 DAC_Trigger 成員 */
  DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
  /* 初始化 DAC_WaveGeneration 成員 */
  DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
  /* 初始化 DAC_LFSRUnmask_TriangleAmplitude 成員 */
  DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
  /* 初始化 DAC_OutputBuffer 成員 */
  DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
}

/**
  * @簡述  使能或失能指定的 DAC 通道.
  * @參數  DAC_Channel: 選定 DAC 通道. 
  *          這個參數可以是下列值之一:
  *          DAC_Channel_1: 選定 DAC 通道1 
  *          DAC_Channel_2: 選定 DAC 通道2  
  * @參數  NewState: DAC 通道的新狀態. 
  *                  這個參數可以是: ENABLE 或 DISABLE.
  * @返回  沒有
  */
void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
{
  /* 檢查參數 */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* 使能指定的 DAC 通道 */
    DAC->CR |= CR_EN_Set << DAC_Channel;
  }
  else
  {
    /* 失能指定的 DAC 通道 */
    DAC->CR &= ~(CR_EN_Set << DAC_Channel);
  }
}

/**
  * @簡述  使能或失能指定的 DAC 通道 DMA 請求.
  * @參數  DAC_Channel: 選定的 DAC 通道. 
  *          這個參數可以是下列值之一:
  *          DAC_Channel_1: 選定 DAC 通道1 
  *          DAC_Channel_2: 選定 DAC 通道2  
  * @參數  NewState: 指定的 DAC 通道 DMA 請求的新狀態.
  *                  這個參數可以是: ENABLE 或 DISABLE.
  * @返回  沒有
  */
void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
{
  /* 檢查參數 */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* 使能指定的 DAC 通道 DMA 請求 */
    DAC->CR |= CR_DMAEN_Set << DAC_Channel;
  }
  else
  {
    /* 失能指定的 DAC 通道 DMA 請求 */
    DAC->CR &= ~(CR_DMAEN_Set << DAC_Channel);
  }
}

/**
  * @簡述  使能或失能選擇的 DAC 通道軟件觸發.
  * @參數  DAC_Channel: 選定的 DAC 通道. 
  *          這個參數可以是下列值之一:
  *          DAC_Channel_1: 選定 DAC 通道1 
  *          DAC_Channel_2: 選定 DAC 通道2  
  * @參數  NewState: 選擇的 DAC 通道軟件觸發的新狀態.
  *                  這個參數可以是: ENABLE 或 DISABLE.
  * @返回  沒有
  */
void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
{
  /* 檢查參數 */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* 使能選擇的 DAC 通道軟件觸發 */
    DAC->SWTRIGR |= SWTRIGR_SWTRIG_Set << (DAC_Channel >> 4);
  }
  else
  {
    /* 失能選擇的 DAC 通道軟件觸發 */
    DAC->SWTRIGR &= ~(SWTRIGR_SWTRIG_Set << (DAC_Channel >> 4));
  }
}

/**
  * @簡述  使能或失能兩個 DAC 通道同步軟件觸發.
  * @參數  NewState: 兩個 DAC 通道同步軟件觸發的新狀態.
  *                  這個參數可以是: ENABLE 或 DISABLE.
  * @返回  沒有
  */
void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
{
  /* 檢查參數 */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* 使能兩個 DAC 通道同步軟件觸發 */
    DAC->SWTRIGR |= DUAL_SWTRIG_Set ;
  }
  else
  {
    /* 失能兩個 DAC 通道同步軟件觸發 */
    DAC->SWTRIGR &= DUAL_SWTRIG_Reset;
  }
}

/**
  * @簡述  使能或失能選擇的 DAC 通道波形發生.
  * @參數  DAC_Channel: 選定的 DAC 通道. 
  *          這個參數可以是下列值之一:
  *          DAC_Channel_1: 選定 DAC 通道1 
  *          DAC_Channel_2: 選定 DAC 通道2 
  * @參數  DAC_Wave: 指定的波形類型.
  *          這個參數可以是下列值之一:
  *          DAC_Wave_Noise:    噪音波形發生
  *          DAC_Wave_Triangle: 三角波形發生
  * @參數  NewState: 選擇的 DAC 通道波形發生的新狀態.
  *                  這個參數可以是: ENABLE 或 DISABLE.
  * @返回  沒有
  */
void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
{
  /* 檢查參數 */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_WAVE(DAC_Wave)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* 使能選擇的 DAC 通道選擇的波形 */
    DAC->CR |= DAC_Wave << DAC_Channel;
  }
  else
  {
    /* 失能選擇的 DAC 通道選擇的波形 */
    DAC->CR &= ~(DAC_Wave << DAC_Channel);
  }
}

/**
  * @簡述  設置 DAC 通道1 選定的數據保持寄存器值.
  * @參數  DAC_Align: DAC 通道1 指定的數據對齊.
  *          這個參數可以是下列值之一:
  *          DAC_Align_8b_R:  選擇8位數據右對齊
  *          DAC_Align_12b_L: 選擇12位數據左對齊
  *          DAC_Align_12b_R: 選擇12位數據右對齊
  * @參數  Data : 裝入選擇的數據保持寄存器的數據.
  * @返回  沒有
  */
void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
{  
  __IO uint32_t tmp = 0;
  
  /* 檢查參數 */
  assert_param(IS_DAC_ALIGN(DAC_Align));
  assert_param(IS_DAC_DATA(Data));
  
  tmp = (uint32_t)DAC_BASE; 
  tmp += DHR12R1_Offset + DAC_Align;

  /* 設置 DAC 通道1 選定的數據保持寄存器值 */
  *(__IO uint32_t *) tmp = Data;
}

/**
  * @簡述  設置 DAC 通道2 選定的數據保持寄存器值.
  * @參數  DAC_Align: DAC 通道2 指定的數據對齊.
  *          這個參數可以是下列值之一:
  *          DAC_Align_8b_R:  選擇8位數據右對齊
  *          DAC_Align_12b_L: 選擇12位數據左對齊
  *          DAC_Align_12b_R: 選擇12位數據右對齊
  * @參數  Data : 裝入選擇的數據保持寄存器的數據.
  * @返回  沒有
  */
void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
{
  __IO uint32_t tmp = 0;

  /* 檢查參數 */
  assert_param(IS_DAC_ALIGN(DAC_Align));
  assert_param(IS_DAC_DATA(Data));
  
  tmp = (uint32_t)DAC_BASE;
  tmp += DHR12R2_Offset + DAC_Align;

  /* 設置 DAC 通道2 選定的數據保持寄存器值 */
  *(__IO uint32_t *)tmp = Data;
}

/**
  * @簡述  設置雙通道 DAC 指定的數據保持寄存器值.
  * @參數  DAC_Align: 雙通道 DAC 指定數據對齊.
  *          這個參數可以是下列值之一:
  *          DAC_Align_8b_R:  選擇8位數據右對齊
  *          DAC_Align_12b_L: 選擇12位數據左對齊
  *          DAC_Align_12b_R: 選擇12位數據右對齊
  * @參數  Data2: DAC通道2 裝載到選擇的數據保持寄存器的數據.
  * @參數  Data1: DAC通道1 裝載到選擇的數據保持寄存器的數據.
  * @返回  沒有
  */
void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
{
  uint32_t data = 0, tmp = 0;
  
  /* 檢查參數 */
  assert_param(IS_DAC_ALIGN(DAC_Align));
  assert_param(IS_DAC_DATA(Data1));
  assert_param(IS_DAC_DATA(Data2));
  
  /* 計算並設置雙 DAC 數據保持寄存器的值 */
  if (DAC_Align == DAC_Align_8b_R)
  {
    data = ((uint32_t)Data2 << 8) | Data1; 
  }
  else
  {
    data = ((uint32_t)Data2 << 16) | Data1;
  }
  
  tmp = (uint32_t)DAC_BASE;
  tmp += DHR12RD_Offset + DAC_Align;

  /* 設置雙 DAC 選擇的數據保持寄存器 */
  *(__IO uint32_t *)tmp = data;
}

/**
  * @簡述  返回最新的 DAC 通道數據寄存器輸出值.
  * @參數  DAC_Channel: 選定的 DAC 通道. 
  *          這個參數可以是下列值之一:
  *          DAC_Channel_1: 選定 DAC 通道1 
  *          DAC_Channel_2: 選定 DAC 通道2 
  * @返回  選定的 DAC 數據輸出值.
  */
uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
{
  __IO uint32_t tmp = 0;
  
  /* 檢查參數 */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  
  tmp = (uint32_t) DAC_BASE ;
  tmp += DOR_Offset + ((uint32_t)DAC_Channel >> 2);
  
  /* 返回選定的 DAC 數據寄存器輸出值 */
  return (uint16_t) (*(__IO uint32_t*) tmp);
}

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/
